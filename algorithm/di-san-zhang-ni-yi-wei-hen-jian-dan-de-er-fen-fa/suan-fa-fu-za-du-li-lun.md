# 算法复杂度理论

我们用复杂度来量化一个算法的时间，空间。在这一小节中，我们讲学习什么是复杂度，什么是时间复杂度，什么是空间复杂度。

在面试中，时间复杂度是问得比较多的，空间复杂度一般不会问。

## 时间复杂度

时间复杂度是面试中必问的问题。学好时间复杂度，有如下的帮助：

1. 面试官会问你的算法时间复杂度是什么
2. 当面试官说，有没有更好的方法时，你知道朝什么样的复杂度优化
3. 利用时间复杂度倒推算法是面试常用技巧。如 O(logN) 的算法几乎可以确定是二分法。

### 什么是算法的时间复杂度

一个算法的运行时间与其所要执行的语句的数量成正比，而所要执行的语句与问题规模正相关。因此算法的时间复杂度可以表示为一个与问题规模 `N` 相关的多项式。

例如下面的代码：\
Java版本：

```java
int sum = 0;
int n = 100;
for (int i = 0; i < n; i++) {
   sum += i;
}
for (int i = 0; i < n; i++) {
   sum += i;
}
```

Python版本：

```python
sum = 0
n = 100
for i in range(n):
    sum += i
for i in range(n):
    sum += i
```

这段代码的运行时间与n的大小正相关，因此，我们可以将其复杂度写成多项式：f(n)=2nf(n)=2n;

在计算机科学中，时间复杂度使用标记O(大写英文字母o)表示，**只包含上述多项式中的最高次项，且忽略最高次项的系数**\
上面这段代码的时间复杂度就是：O(n)。

时间复杂度定性的描述了一个算法的运行时间。（定义参照[WIKI](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)）

更为通俗的定义是：`程序执行了多少句语句`，一条一句被多次执行，就要算多次。

时间复杂度计算的要点：

* **只包含多项式的最高次项。** 这是因为在复杂度计算中，最高次项对运行时间有决定性的作用，次高次项可以忽略不计。例如f(n)=n2+nf(n)=n2+n， 此时n这一项对于多项式的值的影响相对于n2可以忽略不计。在定性的描述中，我们只取最高次项。
* **不包含多项式最高次项的系数。** 对于最高次项，我们忽略它的系数，在算法中，我们称之为常数。上面代码中，常数是2,但是时间复杂度的计算，我们只取O(n)。

在计算算法的时间复杂度时，我们关注其中最耗时的部分，对于相对不那么耗时的部分就忽略不去考虑。也就是上面讲的”只保留最高次项“。

**例子:**\
Java版本：

```java
int sum = 0;
int n = 100;
for (int i = 0; i < n; i++) {
   for (int j = 0; j < n; j++) {
      sum++;
   }
}
for (int i = 0; i < n; i++) {
    sum++;
}
```

Python版本：

```python
sum = 0
n = 100
for i in range(n):
    for j in range(n):
        sum += 1
for i in range(n):
    sum += 1
```

对于上面这段代码，一个两重循环和一个一重循环。\
两重循环的时间复杂度是：**O(n2)**,\
一重循环的时间复杂度是：**O(n)**。\
那么我们标记这段代码的时间复杂度为:**O(n2)**， 而不去考虑那个小的O(n)。\
我们只关心算法中最耗时的部分，并且，假如代码中做了好几次两重循环，我们也不计较这个几次，而是只保留复杂度的“最高次项”，即O(n2)。

### 面试中常见算法的时间复杂度

算法中，常见的时间复杂度有：

| 复杂度        | 可能对应的算法                                               | 备注              |
| ---------- | ----------------------------------------------------- | --------------- |
| O(1)       | 位运算                                                   | 常数级复杂度，一般面试中不会有 |
| O(logn)    | 二分法，倍增法，快速幂算法，辗转相除法                                   |                 |
| O(n)       | 枚举法，双指针算法，单调栈算法，KMP算法，Rabin Karp，Manacher's Algorithm | 又称作线性时间复杂度      |
| O(nlogn)   | 快速排序，归并排序，堆排序                                         |                 |
| O($$n^2$$) | 枚举法，动态规划，Dijkstra                                     |                 |
| O($$n^3$$) | 枚举法，动态规划，Floyd                                        |                 |
| O($$2^n$$) | 与组合有关的搜索问题                                            |                 |
| O(n!)      | 与排列有关的搜索问题                                            |                 |

在面试中，经常会涉及到时间复杂度的计算。当你在对于一个问题给出一种解法之后，面试官常会进一步询问，是否有更优的方法。此时就是在问你是否有时间复杂度更小的方法（有的时候也要考虑空间复杂度更小的方法），这个时候需要你对常用的数据结构操作和算法的时间复杂度有清晰的认识，从而分析出可优化的部分，给出更优的算法。

例如，给定一个已经排序的数组，现在有多次询问，每次询问一个数字是否在这个数组中，返回True or False.

* 方法1： 每次扫描一遍数组，查看是否存在。\
  这个方法，每次查询的时间复杂度是: O(n)。
* 方法2：由于已经有序，可以使用二分查找的方法。\
  这个方法，每次查询的时间复杂度是: O(logn)。
* 方法3：将数组中的数存入Hashset。\
  这个方法，每次查询的时间复杂度是: O(1)。

可以看到，上述的三种方法是递进的，时间复杂度越来越小。

在面试中还有很多常见常用的方法，他们的时间复杂度并不是固定的，都需要掌握其时间复杂度的分析，要能够根据算法过程自己推算出时间复杂度。

### 时间复杂度小练习

计算下面这些代码的时间复杂度

#### 练习 1

Java:

```java
sum = 0;
for (int i = 1; i < n; i *= 2) {
   sum++;
}
```

Python:

```python
sum = 0
i = 0
while i < n:
    sum += 1
    i *= 2
```

C++:

```cpp
int sum = 0;
for (int i = 1; i < n; i *= 2) {
    sum++;
}
```

{% hint style="success" %}
时间复杂度为 O(logn) 如果你将 sum 的值打印出来，就可以发现sum=logn(以2为底)，说明 for 循环共循环了logn次。
{% endhint %}

#### 练习 2

Java

```
sum = 0;
for (int i = 0; i < n; i++) {
   for (int j= 1; j <= n; j *= 2){
      sum++;
   }
}
```

Python

```
sum = 0
for i in range(n):
    j = 1
    while j <= n:
        sum += 1
        j *= 2
```

C++

```
int sum = 0;
for (int i = 0; i < n; i++) {
   for (int j= 1; j <= n; j *= 2){
      sum++;
   }
}
```

{% hint style="success" %}
时间复杂度为 O(nlogn)
{% endhint %}

#### 练习 3

Java:

```
int Fibo(int n) {
    if (n == 0 || n == 1) return 1;
    return Fibo(n - 1) + Fibo(n - 2);
}
```

Python:

```
def Fibo(n):
    if n == 0 or n == 1:
        return 1
    return Fibo(n-1) + Fibo(n-2)
```

C++:

```
int Fibo(int n) {
    if (n == 0 || n == 1) return 1;
    return Fibo(n - 1) + Fibo(n - 2);
}
```

{% hint style="success" %}
时间复杂度为 O(2n2) \~ O(2n)

计算时间复杂度上界：Fibo(n)=Fibo(n−1)+Fibo(n−2)<2∗Fibo(n−1)Fibo(n)=Fibo(n−1)+Fibo(n−2)<2∗Fibo(n−1)\
也就是说，递归版 Fibonacci 的时间复杂度 < T(n)=2∗T(n−1)+O(1)=O(2n)T(n)=2∗T(n−1)+O(1)=O(2n)

再来计算时间复杂度下界：Fibo(n)=Fibo(n−1)+Fibo(n−2)>2∗Fibo(n−2)Fibo(n)=Fibo(n−1)+Fibo(n−2)>2∗Fibo(n−2)\
也就是说，递归版 Fibonacci 的时间复杂度 > T(n)=2∗T(n−2)+O(1)=O(2n2)T(n)=2∗T(n−2)+O(1)=O(22n​)
{% endhint %}

#### 练习 4

Java:

```java
int[] F = new int[50];
F[0] = F[1] = 1;
...
int Fibo(int n) {
    if (F[n] != 0) return F[n];
    F[n] = Fibo(n-1) + Fibo(n-2);
    return F[n];
}
```

Python:

```python
F = [0] * 50
F[0] = F[1] = 1;
...
def Fibo(n):
    if F[n] != 0:
        return F[n]
    F[n] = Fibo(n-1) + Fibo(n-2)
    return F[n]
...
```

C++:

```cpp
int F [50];
F[0] = F[1] = 1;
...
int Fibo(int n) {
    if (F[n] != 0) return F[n];
    F[n] = Fibo(n-1) + Fibo(n-2);
    return F[n];
}
```

{% hint style="success" %}
时间复杂度为 O(n)
{% endhint %}

#### 练习 5

Java:

```
int sum = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        sum++;
    }
}
```

Python:

```
sum = 0
for i in range(n):
    for j in range(i, n):
        sum += 1
```

C++:

```
int sum = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        sum++;
    }
}
```

{% hint style="success" %}
时间复杂度为 O($$n^2$$) i = 0 时，j循环执行 n 次 i = 1 时，j循环执行 n - 1 次 ... i = n - 1 时，j循环执行 1 次 累加所有的执行次数，一共执行了 ( n + n − 1 + n − 2... + 1 ) = ( 1 + n ) ∗ n / 2 (n+n−1+n−2...+1)=(1+n)∗n/2 次 O ( ( 1 + n ) ∗ n / 2 ) = O ( n 2 ) O((1+n)∗n/2)=O(n 2 )
{% endhint %}

#### 练习 6（难）

Java:

```java
int j = 0;
for (int i = 0; i < n; i++) {
    while (j < n && nums[j] - nums[i] < window) {
        j++;
    }
}
```

Python:

```python
j = 0
for i in range(0, n):
    while j < n and nums[j]-nums[i] < window:
        j += 1
```

C++:

```cpp
int j = 0;
for (int i = 0; i < n; i++) {
    while (j < n && nums[j] - nums[i] < window) {
        j++;
    }
}
```

{% hint style="success" %}
时间复杂度为 O ( n ) 这个程序是典型的双指针算法，\[i, j) 是一个滑动窗口的两端，滑动窗口之内的数，两两之差 < window。 你可能会不理解，为什么两重循环的结果不是 O ( n 2 ) ？难道不是几重循环就是几次方么？第二重循环最坏情况不就是会执行 n n 次么？ 大家一定要记住，数循环次数是一个偷懒的时间复杂度计算方法，却不是最准确的时间复杂度计算方法。时间复杂度的定义，是程序总共执行的语句数目的数量级。在这个代码中，执行次数最多的是 j++ 这个循环主体。而这个循环体不会被执行 O ( n 2 ) 次，因为 j 在每次 i 循环的时候，不会被重置到 i 或者 0 的位置开始重新计算。j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。因此总共的执行次数是 O ( n + n ) = O ( n ) O(n+n)=O(n) 而不是O(n∗n)。
{% endhint %}

### 用 T 函数表示法计算时间复杂度

#### T 函数推导法

我们介绍一种时间复杂度的推导方法：`T函数推导法`\
比如二分法。二分法是每次通过 O(1)的时间将规模为 n的问题降低为规模为 n/2 的问题。\
这里我们用 T(n)来表示规模为 n 的问题在该算法下的时间复杂度，那么我们得出推导公式：

T(n)=T(n/2)+O(1)T(n)=T(n/2)+O(1)

我们来逐个说明一下这个公式的意义。

首先 T 代表的是 Time Complexity, n 代表的是问题规模（二分法里就是数组的大小）。\
那么 `T(n)` 代表的就是：`求处理问题规模为n的数据的时间复杂度是多少`。注意这里是一个问句，不是一个答案。\
T(n) 根据算法的不同可以是 O(n) 也可以是O(nlogn) 或任何值，而O(n) 就是 O(n)。

然后 O 代表的是时间复杂度。O(1) 就意味着，你大概用一个 if 语句，或者简单的加加减减，就可以完成。O 在这里的意思是`数量级约等于`。在 O 的世界里，我们只考虑最高项是什么，不考虑系数和常数项。比如：

* O(100n)=O(n)O(100n)=O(n)
* O(n2+n)=O(n2)O(n2+n)=O(n2)
* O(2n+n2+10)=O(2n)O(2n+n2+10)=O(2n)

#### 如何推导 T 函数

我们可以使用不断展开的方法进行推导：

```
T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = T(n/8) + O(1) * 3
     = T(n/16) + O(1) * 4
     ...
     = T(1) + O(1) * logn
     = O(logn)
```

在时间复杂度的领域里，有如下的一些性质：

1. T(1)=O(1)T(1)=O(1) // 解决规模为1的问题通常时间复杂度为O(1)。这个不100%对，但是99.9%的情况下都是如此。
2. k∗O(n)=O(kn)k∗O(n)=O(kn)
3. O(n)+O(m)=O(n+m)O(n)+O(m)=O(n+m)

上面的方法，是采用 T 函数展开的方法，将二分法的时间复杂度最终用 O(...) 来表示。

### T函数推导练习题

#### 练习题 1

有一个算法大致结构如下：

```
while (n > 1) {
   这里执行一个使用 O(n) 的算法，将 n 的规模缩小一半
   n = n / 2
}
```

问该算法的时间复杂度

根据算法，我们可以用`T函数推导法`写出公式：T(n)=T(n/2)+O(n)T(n)=T(n/2)+O(n)

推导过程如下：

```
T(n) = T(n/2) + O(n)
     = T(n/4) + O(n/2) + O(n)
     = T(n/8) + O(n/4) + O(n/2) + O(n)
     = ...
     = O(1) + O(2) + ... O(n/2) + O(n)
     = O(1 + 2 + 4 .. + n/2 + n)
     = O(2n) = O(n)
```

许多同学会拍脑袋认为这个式子的结果是 O(nlogn)，这是错误的。主要错在，当 T(n/2) 往下继续展开的时候，很多同学直接写成 T(n/4) + O(n)，这是不对的。应该是 T(n/4) + O(n/2)。这里我们暂时不能约掉 O(n/2) 里的 `/2`。因为会导致误差累积。

另外一个需要记住的结论就是：`O(1 + 2 + 4 ... + n/2 + n) = O(n)`。这个结论可以通过简单的将 n = 1024 带入计算可以得到：

```
1 + 2 + 4 + ... + 1024 = 2047 ~ 2 * 1024 = O(2n) = O(n)
```

这是一道小学数学题，给整个式子 + 1，然后两个1就变成了一个2，两个2就变成了一个4，以此类推。

#### 练习题 2

请用 T 函数来推导归并排序算法的时间复杂度

归并排序算法的步骤为：

1. 找出数组的中点
2. 将数组分成两个部分递归执行该算法，分别排序两个部分
3. 合并两个排序好的子数组到一个大数组

写成T函数为：T(n)=2∗T(n/2)+O(n)T(n)=2∗T(n/2)+O(n)，其中

* 2∗T(n/2) 代表将 n 的问题，拆分为两个 n/2 的同类问题去进行处理。
* O(n) 代表了，合并两个排好序的 n/2 大小的数组的时间复杂度。

我们用展开的方式推导该算法下的 T(n):

```
T(n) = 2 * T(n/2) + O(n)
     = 2 * (2 * T(n/4) + O(n/2)) + O(n)
     = 4 * T(n/4) + 2 * O(n/2) + O(n)
     = 4 * T(n/4) + 2 * O(n)
     = 4 * (2 * T(n/8) + O(n/4)) + 2 * O(n)
     = 8 * T(n/8) + 3 * O(n)
     = 16 * T(n/16) + 4 * O(n)
     ...
     = n * T(1) + logn * O(n)
     = O(n) + O(nlogn)
     = O(nlogn)
```

#### 练习题 3

如果一个算法，每次通过 O(1) 的时间将 n 的问题拆分为两个 n/2 的问题，求时间复杂度。

首先写出推导函数：T(n)=2∗T(n/2)+O(1)T(n)=2∗T(n/2)+O(1)，然后进行推导：

```
T(n) = 2 * T(n/2) + O(1)
     = 2 * (2 * T(n/4) + O(1)) + O(1)
     = 4 * T(n/4) + O(2 + 1)
     = 8 * T(n/8) + O(4 + 2 + 1)
     ...
     = n * T(1) + O(n/2 + n/4 + ... + 2 + 1)
     = O(n) + O(n)
     = O(n)
```

这里 O(n/2 + n/4 + ... 2 + 1) = O(n) 的推导和练习 1 一样。

## 空间复杂度

面试中很少问到空间复杂度，因为一般来说你看一下你开了多大的数组就是多少，比较简单。本小节中我们快速的学习一下空间复杂度的相关知识。

### 什么是空间复杂度

类似于时间复杂度，空间复杂度就是衡量算法运行时所占用的临时存储空间的度量。也是一个与问题规模nn有关的函数。\
我们同样使用O(大写字母o)来标记。

算法所占用的空间主要有三个方面：算法代码本身占用的空间、输入输出数据占用的空间、算法运行时临时占用的空间。\
其中，代码本身和输入输出数据占用的空间不是算法空间复杂度考虑的范围内，空间复杂度只考虑运行时临时占用的空间，又称为算法的额外空间（Extra space）。

临时占用的空间包括：

* 为参数列表中形参变量分配的空间
* 为函数体中局部变量分配的空间\
  （如果是递归函数，需要将上述两部分占用空间的和乘以递归的深度，这是堆栈空间，在下面小节中详细讲解这部分）

例如：\
Java:

```java
public void insertionSort(int[] A) {
    int n = A.length; 
    for(int i = 1; i < n; i++){
       int t = A[i];
       int index = 0;
       for (int j = i - 1; j >= 0; j--){
           if (A[j] > t){
              A[j + 1] = A[j];
           } else {
              index = j + 1;
              break;
           }
       }
       A[index] = t;
    }
}
```

Python:

```python
def insertionSort(A):
    n = len(A)
    for i in range(1, n):
        t = A[i]
        index = 0
        j = i - 1
        while j >= 0:
            if A[j] > t:
                A[j + 1] = A[j]
            else:
                index = j + 1
                break
            j -= 1
        A[index] = t
    return A
```

C++:

```cpp
void insertionSort(vector<int> A) { 
    int n = A.size(); 
    for(int i = 1; i < n; i++){
       int t = A[i];
       int index = 0;
       for (int j = i - 1; j >= 0; j--){
           if (A[j] > t){
              A[j + 1] = A[j];
           } else {
              index = j + 1;
              break;
           }
       }
       A[index] = t;
    }
}
```

上面这段代码是插入排序的一种实现，其中主要占用的临时空间包括：变量n、t、index、i、jn、t、index、i、j。int\[] A是我们的输入数据，不在我们的临时空间范围内。\
因此这段代码的空间复杂性函数可以写成：f(n)=5f(n)=5，因为无论数组多大，变量的数量就是这么多。\
这段代码的额外空间复杂度是: O(1)。\
与时间复杂度一样，我们只计算最高次项，且忽略最高次项的系数。此处最高次项是 n0=1n0=1。

### 常见算法空间复杂度

在面试中，很多时候面试官给出的问题会附带一个“不能使用多余的空间”这样的要求。很多时候这是在要求你的空间复杂度只能是O(1)的，也就是你只能开几个辅助变量，而不能开大数组。

其他常见的还有，分析一下你的算法空间复杂度，寻找空间复杂度更优的解法等。\
一般来说，算法占用的时间和空间会是两个互相平衡的元素，有的时候我们牺牲空间来换取时间，有的时候我们牺牲时间来换取空间。

在面试中常见算法的空间复杂度：

* 快速排序： 最优：O(logn)，最差:O(n)
* 二分查找： O(1)
* 最短路(Dijkstra)算法： O(V)O(V表示点集大小)

### 运行时堆栈

在递归函数中，除了变量和数组所开辟的临时空间以外，还有一个空间我们需要纳入考虑，就是递归时占用的栈空间（Stack）。

递归函数需要保存当前的环境，以便在递归返回的时候能够还原之前的现场。因此递归的深度越深，所要占用的栈空间越大。当空间超出一定范围的时候就会出现程序**爆栈**（Stack Overflow）的情况。

很多博客文章中会写堆栈空间与递归调用的次数成正比，这个是不完全正确的，应该是与递归的深度成正比（此处只讨论单线程）。\
因为递归在返回到上一层的时侯，就会将本层的空间释放，因此占用的栈空间不会比最深的一次调用所占用的空间更多。

### 如何分析空间复杂度

#### 大部分的空间复杂度计算方法

累加下面两个部分的内容即是你代码的空间复杂度：

1. 你的代码里开辟了多少新的空间（new 了多少新的内容出来）
2. 你的递归深度 \* 递归函数内部的参数和局部变量所占用的空间

#### 以快速排序为例子

快速排序的思路如下：\
1.选择一个基准元素，将原数组分为两部分，左边部分小于该元素，右边部分大于该元素。\
2.分别递归处理左边和右边。

* 最好情况：\
  每次都能恰好将数组分成左右相同长度的两部分，需要的递归深度是:lgn，每次将数组分成两部分时，我们选择不使用辅助数组，在原数组上“就地”处理，所以每层的空间是O(1)。\
  因此总的复杂度是:O(logn)
* 最差情况：\
  每次都将数组分成长度差最大的两部分，即一边只有一个元素，其余的在另外一边，最大深度为：n， 因此空间复杂度为:O(n)。

有些递归算法的空间复杂度是稳定的，不会退化，快排的递归深度与其每次选择的“基准值”有很大关系，因此存在退化的情况。

### 空间复杂度小练习

写出如下算法的空间复杂度

#### 练习 1

Java:

```java
int Fibo(int n) {
    if(n == 0 || n == 1) return 1;
    return Fibo(n-1) + Fibo(n-2);
}
```

Python:

```python
def Fibo(n):
    if n == 0 or n == 1:
        return 1
    return Fibo(n-1) + Fibo(n-2)
```

C++:

```cpp
int Fibo(int n) {
    if(n == 0 || n == 1) return 1;
    return Fibo(n-1) + Fibo(n-2);
}
```

{% hint style="success" %}
O(n)
{% endhint %}

#### 练习 2

Java:

```java
int Fibo(int n) {
    int x1 = 1, x2 = 1, ret = 1;
    for(int i = 2; i <= n; i++){
        ret = x1 + x2;
        x1 = x2;
        x2 = ret;
    }
    return ret;
}
```

Python:

```python
def Fibo(n):
    x1, x2, ret = 1, 1, 1
    for i in range(2, n+1):
        ret = x1 + x2
        x1, x2 = x2, ret
    return ret
```

C++:

```cpp
int Fibo(int n) {
    int x1 = 1, x2 = 1, ret = 1;
    for(int i = 2; i <= n; i++){
        ret = x1 + x2;
        x1 = x2;
        x2 = ret;
    }
    return ret;
}
```

{% hint style="success" %}
O(1)
{% endhint %}

## 分解质因数

以 n​ 为时间复杂度的算法并不多见，最具代表性的就是分解质因数了。

#### 题目描述

[http://www.lintcode.com/problem/prime-factorization/](http://www.lintcode.com/problem/prime-factorization/)

#### 具体步骤

1. 记up=\[n]up=\[n​]，作为质因数k的上界, 初始化k=2k=2。
2. 当k<=upk<=up 且 n不为1 时，执行步骤3，否则执行步骤4。
3. 当n被k整除时，不断整除并覆盖n，同时结果中记录k，直到n不能整出k为止。之后k自增，执行步骤2。
4. 当n不为1时，把n也加入结果当中，算法结束。

#### 几点解释

* 不需要判定k是否为质数，如果k不为质数，且能整出n时，n早被k的因数所除。故能整除n的k必是质数。
* 为何引入up？为了优化性能。当k大于up时，k已不可能整除n，除非k是n自身。也即为何步骤4判断n是否为1，n不为1时必是比up大的质数。
* 步骤2中，也判定n是否为1，这也是为了性能，当n已为1时，可早停。

#### 代码

Java:

```java
public List<Integer> primeFactorization(int n) {
    List<Integer> result = new ArrayList<>();
    int up = (int) Math.sqrt(n);
    
    for (int k = 2; k <= up && n > 1; ++k) {
        while (n % k == 0) {
            n /= k;
            result.add(k);
        }
    }
    
    if (n > 1) {
        result.add(n);
    }
    
    return result;
}
```

Python:

```python
def primeFactorization(n):
    result = []
    up = int(math.sqrt(n));
    
    k = 2
    while k <= up and n > 1: 
        while n % k == 0:
            n //= k
            result.append(k)
        k += 1
            
    if n > 1:
        result.append(n)
        
    return result
```

C++:

```cpp
vector<int> primeFactorization(int n) {
    vector<int> result;
    int up = (int)sqrt(n);
    
    for (int k = 2; k <= up && n > 1; ++k) {
        while (n % k == 0) {
            n /= k;
            result.push_back(k);
        }
    }
    
    if (n > 1) {
        result.push_back(n);
    }
    
    return result;
}
```

#### 复杂度分析

* 最坏时间复杂度 O(n)。当n为质数时，取到其最坏时间复杂度。
* 空间复杂度 O(log(n))，当n质因数很多时，需要空间大，但总不会多于O(log(n))个。

#### 延伸

质因数分解有一种更快的算法，叫做Pollard Rho快速因数分解。该算法时间复杂度为O(n1/4)，其理解起来稍有难度，有兴趣的同学可以进行自学，[参考链接](https://wenku.baidu.com/view/3db5c7a6ad51f01dc381f156.html)。
